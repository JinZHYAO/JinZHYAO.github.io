{"pages":[],"posts":[{"title":"第一篇博客","text":"这是我的第一篇博文。 有些直白，却是对这篇文章最好的概括。 周五决定弄这个博客，从开始上网搜索相关资料，到真正上手操作之前，我本以为一个晚上的时间足够了。然而没想到断断续续的弄了两天，直到周天深夜才开始动笔。期间遇到了很多困难，对于菜鸡的我着实费了很多脑筋，不过还好，最终问题都解决掉了。之后有时间我也会总结一下我搭建这个博客的经验。 说说做这个的原因吧，或是为什么到了现在才做的原因。早在几年前，我就看曾过一篇文章。在文中作者很详细的阐述了一名计算机专业的学生亦或是一名程序员写博客的种种好处。只可惜当时对此不屑一顾便一看了之了。直到现在，为了就业开始学习大量的新知识，参与各种笔试、面试遇到了许多问题，大量的信息如潮水般向我奔涌而来，让我不知所措。这时候我才意识到了有一个博客的重要性，不是为了给别人看，而是给自己一个思考与见证的过程。就像是一本笔记。因此便有了现在的博客，它将会记录我今后的脚步，无论于技术还是于生活，虽然来的晚了些。 我希望我会坚持下去，我也坚信我会坚持下去。 也许若干年后，会有一个年轻人，在这里找到了解决问题的思路或者方法。如现在的我。那这将令人无比的骄傲。 后记：在这期间，发生了两件值得记住的事情 这段时间新闻上报道了各种不太好的消息，让人心情低落，可没想到悲剧再次发生在身边，实属让人扼腕叹息。盛放的花朵骤然凋零，让人难过。希望大家都能乐观的面对生活，只有活着才有希望。 还有一件令人高兴的事情，好朋友心心念念的狗子终于来了！回头方便的话晒几张照片出来。","link":"/2019/12/01/article-1/"},{"title":"XML学习（1）","text":"XML基础 XML简介什么是XML？XML（Extensible Markup Language）可扩展标记语言。是一种标记电子文件使其具有结构性的标记语言。 XML和HTML之间的异同以及特点 XML：被设计用来传输和存储数据 HTML：用来格式化并显示数据 XML是对HTML的补充而不是替代 XML不会做任何事情，只是包裹在XML标签中纯粹的信息 XML标签没有被预定义，需要自定义 XML被设计为具有自我描述性 XML是独立于软件和硬件的信息传输工具 W3C的推荐标准 XML用途常用于简化数据的存储和共享 把数据从HTML分离 简化数据共享 简化数据传输 简化平台变更 使数据更有用 用于创建新的互联网语言 XML树结构XML文档形成了一种树结构，常称为XML树。可以轻易的描述任何XML文档。 一个XML文档实例1&lt;?xml version=\"1.0\" encoding=\"ISO-8895-1\"?&gt;2&lt;note&gt;3 &lt;to&gt;Tove&lt;/to&gt;4 &lt;from&gt;Jani&lt;/from&gt;5 &lt;heading&gt;Reminder&lt;/heading&gt;6 &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;7&lt;/note&gt; 第一行是声明，定义了XML的版本和所使用的编码 第二行是根元素 &lt;note&gt;（像是在说：该文档是个便签） 接下来的是描述根的四个子元素 to , from , heading 和 body 最后是根元素的结尾 &lt;/note&gt; 可以假设该文档是一张Jani写给Tove的便签，由此也可以看出XML其优秀的自我描述性 XML文档的树结构XML文档必须包含根元素。该元素是所有其他元素的父元素，所有的子元素也可以拥有子元素。 1&lt;root&gt;2 &lt;child&gt;3 &lt;subchild&gt; ... &lt;/subchild&gt;4 &lt;/child&gt;5&lt;/root&gt; 父、子以及兄弟用来描述元素之间的关系。父元素拥有子元素，相同层级上的子元素互为兄弟。 实例 1&lt;bookstore&gt;2&lt;book category=\"COOKING\"&gt;3 &lt;title lang=\"en\"&gt;Everyday Italian&lt;/title&gt; 4 &lt;author&gt;Giada De Laurentiis&lt;/author&gt; 5 &lt;year&gt;2005&lt;/year&gt; 6 &lt;price&gt;30.00&lt;/price&gt; 7&lt;/book&gt;8&lt;book category=\"CHILDREN\"&gt;9 &lt;title lang=\"en\"&gt;Harry Potter&lt;/title&gt; 10 &lt;author&gt;J K. Rowling&lt;/author&gt; 11 &lt;year&gt;2005&lt;/year&gt; 12 &lt;price&gt;29.99&lt;/price&gt; 13&lt;/book&gt;14&lt;book category=\"WEB\"&gt;15 &lt;title lang=\"en\"&gt;Learning XML&lt;/title&gt; 16 &lt;author&gt;Erik T. Ray&lt;/author&gt; 17 &lt;year&gt;2003&lt;/year&gt; 18 &lt;price&gt;39.95&lt;/price&gt; 19&lt;/book&gt;20&lt;/bookstore&gt; 例子中的根元素是 &lt;bookstore&gt;。文档中的所有 &lt;book&gt; 元素都被包含在 &lt;bookstore&gt; 中。 &lt;book&gt; 元素有 4 个子元素：&lt;title&gt;、&lt;author&gt;、&lt;year&gt;、&lt;price&gt;。 XML语法 所有的XML元素都必须有一个关闭标签例如： 1&lt;?xml version=\"1.0\" encoding='UTF-8'?&gt;2&lt;p&gt;This is a paragraph.&lt;/p&gt; 注意：声明不是XML文档的一部分，它没有关闭标签。 XML标签对大小写敏感必须使用相同的大小写来编写打开和关闭标签。例如： 1&lt;message&gt; Right &lt;/message&gt;2&lt;Message&gt; Wrong &lt;/message&gt; XML必须正确的嵌套a元素在b元素内打开，那么a也必须在b元素内关闭 XML必须有根元素 XML属性值必须加上引号例如： 1&lt;note data=\"1/1/2020\"&gt; ... &lt;/note&gt; 实体引用 &amp;lt; &lt; less then &amp;gt; &gt; greater then &amp;amp; &amp; ampersand &amp;apos; &apos; apostrophe &amp;quot; &quot; quotation mark XML的注释1&lt;!-- This is a comment --&gt; XML中，空格会被保留 XML以LF存储换行 XML元素什么是XML元素？XML元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。它是XML文档中不可缺少的部分。一个元素可以包含： 其他元素 文本 属性 以上一或多种的混合 XML命名规则XML元素必须遵循以下命名规则： 可以包含字母、数字以及其他字符 不能以数字或者标点符号开始 不能以字母xml（或者XML、Xml等等）开始 不能包含空格 可食用任何名称，没有保留字 XML属性属性是XML元素的一部分，一个元素可以拥有多个属性。属性提供了有关于元素的额外信息。这些信息通常不属于数据组成部分的信息，但可能对处理信息的程序或者软件来说很关键。 XML属性值必须加引号。 单引号或者双引号均可以。如果属性值本身包含双引号可以使用单引号，或是转义引用。 1&lt;person sex='male'&gt; ... &lt;/person&gt;2&lt;person sex=\"male\"&gt; ... &lt;/person&gt;3&lt;player name='\"Magic\"Johnson'&gt; ... &lt;/player&gt;4&lt;player name='&amp;lt;Magic&amp;gt;Johnson'&gt; ... &lt;/player&gt; XML DTDDTD: 文档类型定义 (Docunment Type Definition) 拥有正确语法的XML被称为”形式良好“的XML。通过DTD验证的XML是“合法”的XML。W3C支持一种基于XML的DTD代替者，名为XML Schema。 XML 和 CSS，XSLT可以使用CSS样式表来格式化XML文档，但推荐使用XSLT，是首选的XML样式表语言。","link":"/2019/12/17/article-2/"},{"title":"XML学习（2）","text":"XML JavaScript XMLHttpRequest 对象XMLHttpRequest 对象XMLHttpRequest 对象用于在后台与服务器交换数据。 拥有以下特点： 在不重新加载页面的情况下更新网页 在页面已加载后从服务器请求数据 在页面已加载后从服务器接收数据 在后台向服务器发送数据 创建一个 XMLHttpRequest 对象创建XMLHttpRequest对象的语法： 1xmlhttp = new XMLHttpRequest(); 旧版本的Internet Explorer（IE5、IE6）中使用ActiveX 对象： 1xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); XML Parser所有现代浏览器都有内建的XML解析器。 XML解析器把XML文档转换为XML DOM对象 - 可通过JavaScript操作的对象。 XML DOMDOM (Document Object Model) 文档对象模型：定义了访问和操作文档的标准方法。 XML DOMXML DOM 定义了访问和操作XML文档的标准方法。 XML DOM把XML文档作为树结构来查看。所有元素可以通过DOM树来访问，可以修改或删除它们的内容，并创建新的元素。元素，其文本及其属性都被认为是节点。 加载一个XML文件 - 跨浏览器实例下面的例子将XML文档解析到XML DOM对象中，然后通过JavaScript提取一些信息： 1&lt;html&gt;2&lt;body&gt;3&lt;h1&gt;W3Schools Internal Note&lt;/h1&gt;4&lt;div&gt;5&lt;b&gt;To:&lt;/b&gt; &lt;span id=\"to\"&gt;&lt;/span&gt;&lt;br /&gt;6&lt;b&gt;From:&lt;/b&gt; &lt;span id=\"from\"&gt;&lt;/span&gt;&lt;br /&gt;7&lt;b&gt;Message:&lt;/b&gt; &lt;span id=\"message\"&gt;&lt;/span&gt;8&lt;/div&gt;910&lt;script&gt;11if (window.XMLHttpRequest)12{// code for IE7+, Firefox, Chrome, Opera, Safari13xmlhttp=new XMLHttpRequest();14}15else16{// code for IE6, IE517xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");18}19xmlhttp.open(\"GET\",\"note.xml\",false);20xmlhttp.send();21xmlDoc=xmlhttp.responseXML;2223document.getElementById(\"to\").innerHTML=24xmlDoc.getElementsByTagName(\"to\")[0].childNodes[0].nodeValue;25document.getElementById(\"from\").innerHTML=26xmlDoc.getElementsByTagName(\"from\")[0].childNodes[0].nodeValue;27document.getElementById(\"message\").innerHTML=28xmlDoc.getElementsByTagName(\"body\")[0].childNodes[0].nodeValue;29&lt;/script&gt;3031&lt;/body&gt;32&lt;/html&gt; 注意：如需从上面的 XML 文件的 &lt;to&gt;元素中提取文本 “Tove”，语法是： 1getElementsByTagName(&quot;to&quot;)[0].childNodes[0].nodeValue 请注意，即使 XML 文件只包含一个 元素，您仍然必须指定数组索引 [0]。这是因为 getElementsByTagName() 方法返回一个数组。 加载一个 XML 字符串 - 跨浏览器实例下面的实例把 XML 字符串解析到 XML DOM 对象中，然后通过 JavaScript 提取一些信息： 1&lt;html&gt;2&lt;body&gt;3&lt;h1&gt;W3Schools Internal Note&lt;/h1&gt;4&lt;div&gt;5&lt;b&gt;To:&lt;/b&gt; &lt;span id=\"to\"&gt;&lt;/span&gt;&lt;br /&gt;6&lt;b&gt;From:&lt;/b&gt; &lt;span id=\"from\"&gt;&lt;/span&gt;&lt;br /&gt;7&lt;b&gt;Message:&lt;/b&gt; &lt;span id=\"message\"&gt;&lt;/span&gt;8&lt;/div&gt;910&lt;script&gt;11txt=\"&lt;note&gt;\";12txt=txt+\"&lt;to&gt;Tove&lt;/to&gt;\";13txt=txt+\"&lt;from&gt;Jani&lt;/from&gt;\";14txt=txt+\"&lt;heading&gt;Reminder&lt;/heading&gt;\";15txt=txt+\"&lt;body&gt;Don't forget me this weekend!&lt;/body&gt;\";16txt=txt+\"&lt;/note&gt;\";1718if (window.DOMParser)19{20parser=new DOMParser();21xmlDoc=parser.parseFromString(txt,\"text/xml\");22}23else // Internet Explorer24{25xmlDoc=new ActiveXObject(\"Microsoft.XMLDOM\");26xmlDoc.async=false;27xmlDoc.loadXML(txt);28}2930document.getElementById(\"to\").innerHTML=31xmlDoc.getElementsByTagName(\"to\")[0].childNodes[0].nodeValue;32document.getElementById(\"from\").innerHTML=33xmlDoc.getElementsByTagName(\"from\")[0].childNodes[0].nodeValue;34document.getElementById(\"message\").innerHTML=35xmlDoc.getElementsByTagName(\"body\")[0].childNodes[0].nodeValue;36&lt;/script&gt;37&lt;/body&gt;38&lt;/html&gt; HTML 页面显示 XML 数据在下面的实例中，我们打开一个 XML 文件，然后遍历每个 CD 元素，并显示HTML 表格中的 ARTIST 元素和 TITLE 元素的值： 1&lt;html&gt;2&lt;body&gt;34&lt;script&gt;5if (window.XMLHttpRequest)6{// code for IE7+, Firefox, Chrome, Opera, Safari7xmlhttp=new XMLHttpRequest();8}9else10{// code for IE6, IE511xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");12}13xmlhttp.open(\"GET\",\"cd_catalog.xml\",false);14xmlhttp.send();15xmlDoc=xmlhttp.responseXML;1617document.write(\"&lt;table border='1'&gt;\");18var x=xmlDoc.getElementsByTagName(\"CD\");19for (i=0;i&lt;x.length;i++)20{21document.write(\"&lt;tr&gt;&lt;td&gt;\");22document.write(x[i].getElementsByTagName(\"ARTIST\")[0].childNodes[0].nodeValue);23document.write(\"&lt;/td&gt;&lt;td&gt;\");24document.write(x[i].getElementsByTagName(\"TITLE\")[0].childNodes[0].nodeValue);25document.write(\"&lt;/td&gt;&lt;/tr&gt;\");26}27document.write(\"&lt;/table&gt;\");28&lt;/script&gt;2930&lt;/body&gt;31&lt;/html&gt; 效果截图：","link":"/2019/12/19/article-3/"},{"title":"XML学习（3）","text":"XML 进阶 - 1 XML 命名空间XML 命名空间提供避免元素名冲突的方法。 命名冲突在 XML 中，元素名称是由开发者定义的，当两个不同的文档使用相同的元素名时，就会发生命名冲突。 例如某个 XML 文档中携带关于 HTML 中表格的信息，具有 &lt;table&gt; 标签。而另一个 XML 文档中描述了一张桌子，也具有 &lt;table&gt; 标签。如果这两个 XML 文档被一起使用，由于两个文档都包含带有不同内容和定义的 &lt;table&gt; 元素，就会发生命名冲突。 XML 解析器无法确定如何处理这类冲突。 使用前缀来避免命名冲突在 XML 中的命名冲突可以通过使用名称前缀从而容易地避免。 上面的例子中将两个标签分别加上前缀就可解决冲突，例如：&lt;h:table&gt; 和 &lt;f:table&gt;。这样两个 &lt;table&gt; 元素有着并不同的名称就可避免冲突。 XML 命名空间 - xmlns 属性当在 XML 中使用前缀时，一个所谓的用于前缀的命名空间必须被定义。 命名空间是在元素的开始标签的 xmlns 属性中定义的。声明的语法如下： 1xmlns：前缀 = &quot;URL&quot; 例如： 1&lt;root&gt;23&lt;h:table xmlns:h=\"http://www.w3.org/TR/html4/\"&gt;4&lt;h:tr&gt;5&lt;h:td&gt;Apples&lt;/h:td&gt;6&lt;h:td&gt;Bananas&lt;/h:td&gt;7&lt;/h:tr&gt;8&lt;/h:table&gt;910&lt;f:table xmlns:f=\"http://www.w3cschool.cc/furniture\"&gt;11&lt;f:name&gt;African Coffee Table&lt;/f:name&gt;12&lt;f:width&gt;80&lt;/f:width&gt;13&lt;f:length&gt;120&lt;/f:length&gt;14&lt;/f:table&gt;1516&lt;/root&gt; 在上面的实例中，&lt;table&gt; 标签的 xmlns 属性定义了 h: 和 f: 前缀的合格命名空间。 当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。 命名空间，可以在他们被使用的元素中或者在 XML 根元素中声明： 1&lt;root xmlns:h=\"http://www.w3.org/TR/html4/\"2xmlns:f=\"http://www.w3cschool.cc/furniture\"&gt;3...4&lt;/root&gt; 注释：命名空间 URI 不会被解析器用于查找信息。 其目的是赋予命名空间一个惟一的名称。不过，很多公司常常会作为指针来使用命名空间指向实际存在的网页，这个网页包含关于命名空间的信息。 统一资源标识符 （URI，Uniform Resource Identifier）统一资源标识符（URI）是一串可以标识因特网资源的字符。 最常用的 URI 是用来标识因特网域名地址的统一资源定位器（URL）。另一个不那么常用的 URI 是统一资源命名（URN）。 默认的命名空间为元素定义默认的命名空间，语法如下： 1xmlns=&quot;namespaceURI&quot; 实际使用中的命名空间XSLT 是一种用于把 XML 文档转换为其他格式的 XML 语言，比如 HTML。 在下面的 XSLT 文档中，您可以看到，大多数的标签是 HTML 标签。 非 HTML 的标签都有前缀 xsl，并由此命名空间标识：xmlns:xsl=”http://……”： 1&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;23&lt;xsl:stylesheet version=\"1.0\"4xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt;56&lt;xsl:template match=\"/\"&gt;7&lt;html&gt;8&lt;body&gt;9&lt;h2&gt;My CD Collection&lt;/h2&gt;10&lt;table border=\"1\"&gt;11&lt;tr&gt;12&lt;th align=\"left\"&gt;Title&lt;/th&gt;13&lt;th align=\"left\"&gt;Artist&lt;/th&gt;14&lt;/tr&gt;15&lt;xsl:for-each select=\"catalog/cd\"&gt;16&lt;tr&gt;17&lt;td&gt;&lt;xsl:value-of select=\"title\"/&gt;&lt;/td&gt;18&lt;td&gt;&lt;xsl:value-of select=\"artist\"/&gt;&lt;/td&gt;19&lt;/tr&gt;20&lt;/xsl:for-each&gt;21&lt;/table&gt;22&lt;/body&gt;23&lt;/html&gt;24&lt;/xsl:template&gt;2526&lt;/xsl:stylesheet&gt; XML CDATAXML 文档中的所有文本均会被解析器解析。只有在 CDATA 区段中的文本会被解析器忽略。 PCDATA - 被解析的字符数据XML 解析器通常会解析 XML 文档中所有的文本。 当某个 XML 元素被解析时，其标签之间的文本也会被解析： 1&lt;message&gt;This text is also parsed&lt;/message&gt; 解析器之所以这么做是因为 XML 元素可包含其他元素，就像这个实例中，其中的 &lt;name&gt; 元素包含着另外的两个元素（first 和 last）： 1&lt;name&gt;&lt;first&gt;Bill&lt;/first&gt;&lt;last&gt;Gates&lt;/last&gt;&lt;/name&gt; 而解析器会把它分解为像这样的子元素： 1&lt;name&gt;2&lt;first&gt;Bill&lt;/first&gt;3&lt;last&gt;Gates&lt;/last&gt;4&lt;/name&gt; 解析字符数据（PCDATA）是 XML 解析器解析的文本数据使用的一个术语。 CDATA - （未解析）字符数据术语 CDATA 是不应该由 XML 解析器解析的文本数据。 像 “&lt;” 和 “&amp;” 字符在 XML 元素中都是非法的。 “&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始。 “&amp;” 会产生错误，因为解析器会把该字符解释为字符实体的开始。 某些文本，比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。 CDATA 部分中的所有内容都会被解析器忽略。 CDATA 部分由 “&lt;![CDATA[“ 开始，由 “]]&gt;“ 结束： 1&lt;script&gt;2&lt;![CDATA[3function matchwo(a,b)4{5if (a &lt; b &amp;&amp; a &lt; 0) then6{7return 1;8}9else10{11return 0;12}13}14]]&gt;15&lt;/script&gt; 在上面的实例中，解析器会忽略 CDATA 部分中的所有内容。 关于 CDATA 部分的注释： CDATA 部分不能包含字符串 “]]&gt;”。也不允许嵌套的 CDATA 部分。 标记 CDATA 部分结尾的 “]]&gt;” 不能包含空格或换行。 XML 编码XML 文档可以包含非 ASCII 字符，比如挪威语 æ ø å，或者法语 ê è é。 为了避免错误，需要规定 XML 编码，或者将 XML 文件存为 Unicode。 XML 编码错误如果您载入一个 XML 文档，您可以得到两个不同的错误，表示编码问题： 在文本内容中发现无效字符。 如果您的 XML 中包含非 ASCII 字符，且文件保存为没有指定编码的单字节 ANSI（或 ASCII），您会得到一个错误。 将当前编码切换为不被支持的指定编码 如果您的 XML 文件保存为带有指定的单字节编码（WINDOWS-1252、ISO-8859-1、UTF-8）的双字节 Unicode（或 UTF-16），您会得到一个错误。 如果您的 XML 文件保存为带有指定的双字节编码（UTF-16）的单字节 ANSI（或 ASCII），您也会得到一个错误。 结论 始终使用编码属性 使用支持编码的编辑器 确保您知道编辑器使用什么编码 在您的编码属性中使用相同的编码","link":"/2019/12/19/article-4/"},{"title":"XML学习（4）","text":"XML 进阶 - 2 服务器上的 XMLXML是类似于HTML文件的纯文本文件。可以通过标准的Web服务器轻松的存储和生成。 详见: https://www.runoob.com/xml/xml-server.html 高级 XML DOM示例文件： 1&lt;bookstore&gt;2&lt;book category=\"COOKING\"&gt;3&lt;title lang=\"en\"&gt;Everyday Italian&lt;/title&gt;4&lt;author&gt;Giada De Laurentiis&lt;/author&gt;5&lt;year&gt;2005&lt;/year&gt;6&lt;price&gt;30.00&lt;/price&gt;7&lt;/book&gt;8...9&lt;/bookstore&gt; ### 获取元素的值 例如：检索第一个 &lt;title&gt; 元素的文本值 1txt=xmlDoc.getElementsByTagName(\"title\")[0].childNodes[0].nodeValue; 获取属性的值例如：检索第一个 &lt;title&gt; 元素的 “lang” 属性的文本值： 1txt=xmlDoc.getElementsByTagName(\"title\")[0].getAttribute(\"lang\"); 改变元素的值例如：改变第一个 &lt;title&gt; 元素的文本值： 1x=xmlDoc.getElementsByTagName(\"title\")[0].childNodes[0];2x.nodeValue=\"Easy Cooking\"; 创建新的属性XML DOM 的 setAttribute() 方法可用于改变现有的属性值，或创建一个新的属性。 下面的实例创建了一个新的属性（edition=”first”），然后把它添加到每一个 &lt;book&gt; 元素中： 1x=xmlDoc.getElementsByTagName(\"book\");23for(i=0;i&lt;x.length;i++)4{5x[i].setAttribute(\"edition\",\"first\");6} 创建元素XML DOM 的 createElement() 方法创建一个新的元素节点。 XML DOM 的 createTextNode() 方法创建一个新的文本节点。 XML DOM 的 appendChild() 方法向节点添加子节点（在最后一个子节点之后）。 如需创建带有文本内容的新元素，需要同时创建元一个新的元素节点和一个新的文本节点，然后把他追加到现有的节点。 下面的实例创建了一个新的元素（&lt;edition&gt;），带有如下文本：First，然后把它添加到第一个 &lt;book&gt; 元素： 1newel=xmlDoc.createElement(\"edition\");2newtext=xmlDoc.createTextNode(\"First\");3newel.appendChild(newtext);45x=xmlDoc.getElementsByTagName(\"book\");6x[0].appendChild(newel); 实例解释: 创建一个 &lt;edition&gt; 元素 创建值为 “First” 的文本节点 把这个文本节点追加到新的 &lt;edition&gt; 元素 把 &lt;edition&gt; 元素追加到第一个 &lt;book&gt; 元素 删除元素下面的实例删除第一个 &lt;book&gt; 元素的第一个节点： 1x=xmlDoc.getElementsByTagName(\"book\")[0];2x.removeChild(x.childNodes[0]);","link":"/2019/12/20/article-5/"},{"title":"SVG学习（2）","text":"SVG形状 矩形 &lt;rect&gt;1&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt;2 &lt;rect x=\"50\" y=\"20\" rx=\"20\" ry=\"20\" width=\"120\" height=\"100\"3 style=\"fill:blue;stroke:pink;stroke-width:5;fill-opacity:0.1;4 stroke-opacity:0.9;opacity:0.5\"/&gt;5&lt;/svg&gt; rect 元素的 width 和 height 属性可定义矩形的宽度和高度，x 和 y 定义矩形的左侧位置和顶端位置，rx 和 ry 属性使矩形产生圆角。 style 属性用来定义 CSS 属性: fill 矩形的填充颜色，使用rgb值、颜色名或者十六进制值 stroke-width 定义矩形边框的宽度 stroke 定义矩形边框的颜色 opacity 定义填充颜色透明度 （合法范围：0-1） fill-opacity 定义填充颜色透明度 （合法范围：0-1） stroke-opacity 定义轮廓颜色的透明度 （合法范围：0-1） 圆形 &lt;circle&gt;1&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt;2 &lt;circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\"3 stroke-width=\"2\" fill=\"red\"/&gt;4&lt;/svg&gt; cx 和 cy 属性定义圆心的坐标，如省略则坐标为（0 , 0） r 属性定义圆的半径 椭圆 &lt;ellipse&gt;1&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt;2 &lt;ellipse cx=\"150\" cy=\"80\" rx=\"100\" ry=\"50\"3 style=\"fill:yellow;stroke:purple;stroke-width:2\"/&gt;4&lt;/svg&gt; cx 和 cy 定义了椭圆中心的坐标，rx 和 ry 定义了椭圆的水平半径和垂直半径 线&lt;line&gt;1&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt;2 &lt;line x1=\"0\" y1=\"0\" x2=\"200\" y2=\"200\"3 style=\"stroke:rgb(255,0,0);stroke-width:2\"/&gt;4&lt;/svg&gt; x1 , y1 属性定义了线开始的坐标 (x1 , y1) x2 , y2 属性定义了线结束的坐标 (x2 , y2) 折线&lt;polyline&gt;1&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt;2 &lt;polyline points=\"0,40 40,40 40,80 80,80 80,120 120,120 120,160\" style=\"fill:white;stroke:red;stroke-width:4\" /&gt;3&lt;/svg&gt; 用于创建任何只有直线的形状。points属性是各点的坐标。 多边形&lt;polygon&gt;1&lt;svg height=\"210\" width=\"500\"&gt;2 &lt;polygon points=\"100,10 40,198 190,78 10,78 160,198\"3 style=\"fill:lime;stroke:purple;stroke-width:5;fill-rule:nonzero;\" /&gt;4&lt;/svg&gt; 用来创建含有不少于三个边的图形。points 属性定义多边形每个角的 x 和 y 坐标 路径&lt;path&gt;path元素的形状是由通过属性 d 定义的，属性 d 的值是一个“命令 + 参数 ” 的序列，描述了一个点集数列以及如何绘制路径的信息。每一种命令都有大写和小写两种形式。大写字母，表示采用绝对定位。小写字母，表示采用相对定位。 直线命令Move to1M x y2m dx dy 两个参数代表需要移动到的位置的x和y坐标。M命令仅可以移动画笔，并不会在两个点之间画线。所以M命令通常出现在路径的开始位置，来指明从何处开始画。 Line to1L x y2l dx dy 两个参数代表新位置的x和y坐标，L坐标将会在当前位置和新位置之间画一条线段。 H &amp; V1H x ( h dx )2V y ( v dy ) H 绘制水平线。 V 绘制垂直线。 它们都只带有一个参数，表明在x或y轴将要移动到的位置，因为它们只在坐标轴的一个方向上移动。 Z1Z ( or z ) 闭合路径指令，在当前点画一条直线到路径的起点。Z命令不区分大小写。 曲线命令贝塞尔曲线C 三次贝塞尔曲线 &amp; S1C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy) 三次贝塞尔曲线需要定义一个点和两个控制点，这里的最后一个坐标(x,y)表示的是曲线的终点，另外两个坐标是控制点，(x1,y1)是起点的控制点，(x2,y2)是终点的控制点。 控制点描述的是曲线起始点的斜率，曲线上各个点的斜率，是从起点斜率到终点斜率的渐变过程。 1S x2 y2, x y (or s dx2 dy2, dx dy) S命令可以用来创建与前面一样的贝塞尔曲线，但是，如果S命令跟在一个C或S命令后面，则它的第一个控制点会被假设成前一个命令曲线的第二个控制点的中心对称点。如果S命令单独使用，前面没有C或S命令，那当前点将作为第一个控制点。 Q 二次贝塞尔曲线 &amp; T1Q x1 y1, x y (or q dx1 dy1, dx dy) 只需要一个控制点，用来确定起点和终点的曲线斜率。因此它需要两组参数，控制点和终点坐标。 1T x y (or t dx dy) 快捷命令T会通过前一个控制点，推断出一个新的控制点。需要注意的是，T命令前面必须是一个Q命令，或者是另一个T命令。如果T单独使用，那么控制点就会被认为和终点是同一个点，所以画出来的将是一条直线。 弧形A1A rx ry x-axis-rotation large-arc-flag sweep-flag x y2a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy 弧形命令A的前两个参数分别是x轴半径和y轴半径,的第三个参数表示弧形的旋转情况,large-arc-flag（角度大小） 和sweep-flag（弧线方向），large-arc-flag决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。sweep-flag表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧，最后两个参数是指定弧形的终点。 贝塞尔曲线学习： https://www.jianshu.com/p/8f82db9556d2","link":"/2019/12/28/article-7/"},{"title":"测试文章","text":"《 陋 室 铭 》刘禹锡山不在高 有仙则名 水不在深 有龙则灵 斯是陋室 惟吾德馨苔痕上阶绿 草色入帘青 谈笑有鸿儒 往来无白丁可以调素琴 阅金经 无丝竹之乱耳 无案牍之劳形南阳诸葛庐 西蜀子云亭 孔子云 何陋之有","link":"/2019/11/30/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"},{"title":"SVG学习（1）","text":"SVG基础 SVG简介SVG 意为 可缩放矢量图形 (Scalable Vector Graphics) 是一种基于可扩展标记语言(XML)，用于描述二维矢量图形的图形格式。SVG由W3C制定，是一个开放标准。 SVG 优点 SVG可被很多的工具读取和修改(例如记事本) SVG和JPEG、GIF图像比起来，尺寸更小，且压缩性更强 SVG是可伸缩的 SVG可在任何分辨率下被高质量的打印 SVG可在图像质量不下降的情况下被放大 SVG图像中的文本时可选的，同时也是可搜索的 SVG可以与JAVA技术一起运行 SVG是开放的标准 SVG是纯粹的XML 实例1&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;2&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"3\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;45&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt;6 &lt;circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\"7 stroke-width=\"2\" fill=\"blue\" /&gt;8&lt;/svg&gt; 第一行为XML声明。standalone属性规定了该SVG文件是否为”独立的“，或含有对外部文件的引用。standalone=“no”代表SVG文档会引用一个文件，此处引用的是DTD文件。 第二行，第三行引用了这个外部的SVG DTD。该DTD位于W3C，含有所有允许的SVG元素。 SVG 代码以 &lt;svg&gt; 元素开始，包括开始标签 &lt;svg&gt; 和结束标签 &lt;/svg&gt; ，这是根元素。width 和 height 属性可设置此 SVG 文档的宽度和高度。version 属性可定义所使用的 SVG 版本，xmlns属性可定义 SVG 的命名空间。 SVG 的 &lt;circle&gt; 用来创建一个圆。cx 和 cy 属性定义圆中心的 x 和 y 坐标。如果忽略这两个属性，那么圆心坐标会被设置为 ( 0 , 0 )。r 属性定义圆的半径。stroke 和 stroke-width 属性控制如何显示形状的轮廓。我们把轮廓设置为2px宽，黑边框。fill 属性设置形状内的颜色。 SVG 在 HTML可以使用&lt;embed&gt;,&lt;object&gt;或者&lt;iframe&gt;在 HTML 文档中嵌入SVG文件。SVG代码也可以直接嵌入到 HTML 文档中。img ，a标签也可以引用。css中也可。 例如： 1&lt;embed src=\"circle1.svg\" type=\"image/svg+xml\" /&gt;2&lt;object data=\"circle1.svg\" type=\"image/svg+xml\"&gt;&lt;/object&gt;3&lt;iframe src=\"circle1.svg\"&gt;&lt;/iframe&gt;4&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt;5 &lt;circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"2\" fill=\"red\" /&gt;6&lt;/svg&gt;","link":"/2019/12/27/article-6/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/11/29/hello-world/"},{"title":"测试文章2","text":"欢迎来到我的博客 文字测试诗锦瑟锦瑟无端五十弦，一弦一柱思华年。 庄生晓梦迷蝴蝶，望帝春心托杜鹃。 沧海月明珠有泪，蓝田日暖玉生烟。 此情可待成追忆？只是当时已惘然。 词定风波·莫听穿林打叶声三月七日，沙湖道中遇雨。雨具先去，同行皆狼狈，余独不觉。已而遂晴，故作此词。 莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。 料峭春风听酒醒，微冷，山头斜照却相迎。回首向来萧瑟处，归去，也无风雨也无晴。 文阿房宫赋​ 六王毕，四海一；蜀山兀，阿房出。覆压三百余里，隔离天日。骊山北构而西折，直走咸阳。二川溶溶，流入宫墙。五步一楼，十步一阁；廊腰缦回，檐牙高啄；各抱地势，钩心斗角。盘盘焉，囷囷焉，蜂房水涡，矗不知其几千万落！长桥卧波，未云何龙？复道行空，不霁何虹？高低冥迷，不知西东。歌台暖响，春光融融；舞殿冷袖，风雨凄凄。一日之内，一宫之间，而气候不齐。​ 妃嫔媵嫱，王子皇孙，辞楼下殿，辇来于秦，朝歌夜弦，为秦宫人。明星荧荧，开妆镜也；绿云扰扰，梳晓鬟也；渭流涨腻，弃脂水也；烟斜雾横，焚椒兰也。雷霆乍惊，宫车过也；辘辘远听，杳不知其所之也。一肌一容，尽态极妍，缦立远视，而望幸焉；有不得见者，三十六年。​ 燕、赵之收藏，韩、魏之经营，齐、楚之精英，几世几年，剽掠其人，倚叠如山。一旦不能有，输来其间。鼎铛玉石，金块珠砾，弃掷逦迤，秦人视之，亦不甚惜。​ 嗟乎！一人之心，千万人之心也。秦爱纷奢，人亦念其家；奈何取之尽锱铢，用之如泥沙？使负栋之柱，多于南亩之农夫；架梁之椽，多于机上之工女；钉头磷磷，多于在庾之粟粒；瓦缝参差，多于周身之帛缕；直栏横槛，多于九土之城郭；管弦呕哑，多于市人之言语。使天下之人，不敢言而敢怒；独夫之心，日益骄固。戍卒叫，函谷举；楚人一炬，可怜焦土。​ 呜呼！灭六国者，六国也，非秦也。族秦者，秦也，非天下也。嗟乎！使六国各爱其人，则足以拒秦；使秦复爱六国之人，则递三世可至万世而为君，谁得而族灭也？秦人不暇自哀，而后人哀之；后人哀之而不鉴之，亦使后人而复哀后人也。 插图测试 ​ Nothing Stops Detroit ​ Michal Jordan 代码测试C++ 代码Hello World 1#include &lt;iostream&gt;2using namespace std;3int main(){4 cout&lt;&lt;\"Hello World1！\"&lt;&lt;endl;5 return 0; 6} C 代码Hello World 1#include &lt;stdio.h&gt;2int main(){3 printf(\"Hello World!\\n\");4 return 0;5}","link":"/2019/12/01/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A02/"}],"tags":[{"name":"文字","slug":"文字","link":"/tags/%E6%96%87%E5%AD%97/"},{"name":"XML","slug":"XML","link":"/tags/XML/"},{"name":"SVG","slug":"SVG","link":"/tags/SVG/"},{"name":"测试文章","slug":"测试文章","link":"/tags/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"},{"name":"古诗文","slug":"古诗文","link":"/tags/%E5%8F%A4%E8%AF%97%E6%96%87/"},{"name":"图集","slug":"图集","link":"/tags/%E5%9B%BE%E9%9B%86/"}],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"SVG","slug":"学习笔记/SVG","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SVG/"},{"name":"XML","slug":"学习笔记/XML","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/XML/"},{"name":"测试","slug":"测试","link":"/categories/%E6%B5%8B%E8%AF%95/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"}]}